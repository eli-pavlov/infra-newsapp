# .github/workflows/diagnostics.yml
name: OCI & Terraform Diagnostics

on:
  workflow_dispatch: {} # Allows manual triggering

permissions:
  contents: read

jobs:
  diagnose:
    runs-on: ubuntu-latest
    env:
      # These secrets are loaded into the environment for the diagnostic steps
      TF_VAR_tenancy_ocid:        ${{ secrets.OCI_TENANCY_OCID }}
      TF_VAR_user_ocid:           ${{ secrets.OCI_USER_OCID }}
      TF_VAR_fingerprint:         ${{ secrets.OCI_FINGERPRINT }}
      TF_VAR_region:              ${{ secrets.OCI_REGION }}
      TF_VAR_private_key_pem:     ${{ secrets.OCI_PRIVATE_KEY_PEM }}
      TF_VAR_compartment_ocid:    ${{ secrets.COMPARTMENT_OCID }}
      TF_VAR_availability_domain: ${{ secrets.AVAILABILITY_DOMAIN }}
      TF_VAR_os_image_id:         ${{ secrets.OS_IMAGE_ID }}
      TF_VAR_bastion_os_image_id:   ${{ secrets.BASTION_IMAGE }}
      ADMIN_CIDRS:                ${{ secrets.ADMIN_CIDRS }}
      CLOUDFLARE_CIDRS:           ${{ secrets.CLOUDFLARE_CIDRS }}
      TF_STATE_BUCKET:            ${{ secrets.TF_STATE_BUCKET }}
      TF_STATE_KEY:               ${{ secrets.TF_STATE_KEY }}
      OS_NAMESPACE:               ${{ secrets.OS_NAMESPACE }}
      T_SEALED_SECRETS_CERT:      ${{ secrets.T_SEALED_SECRETS_CERT }}
      T_SEALED_SECRETS_KEY:       ${{ secrets.T_SEALED_SECRETS_KEY }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install tools (jq, oci-cli, openssl)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq openssl
          pip install --quiet oci-cli

      - name: 1. Create Diagnostic Output File
        id: create-file
        shell: bash
        run: |
          echo "### Writing critical variables to a local JSON file ###"
          jq -n \
            --arg tf_var_tenancy_ocid "${TF_VAR_tenancy_ocid}" \
            --arg tf_var_user_ocid "${TF_VAR_user_ocid}" \
            --arg tf_var_fingerprint "${TF_VAR_fingerprint}" \
            --arg tf_var_region "${TF_VAR_region}" \
            --arg tf_var_private_key_pem "${TF_VAR_private_key_pem}" \
            --arg tf_var_compartment_ocid "${TF_VAR_compartment_ocid}" \
            --arg tf_var_availability_domain "${TF_VAR_availability_domain}" \
            --arg tf_var_os_image_id "${TF_VAR_os_image_id}" \
            --arg tf_var_bastion_os_image_id "${TF_VAR_bastion_os_image_id}" \
            --arg admin_cidrs "${ADMIN_CIDRS}" \
            --arg cloudflare_cidrs "${CLOUDFLARE_CIDRS}" \
            --arg ssh_public_key "${SSH_PUBLIC_KEY}" \
            --arg tf_state_bucket "${TF_STATE_BUCKET}" \
            --arg tf_state_key "${TF_STATE_KEY}" \
            --arg os_namespace "${OS_NAMESPACE}" \
            '{
              "tf_var_tenancy_ocid": $tf_var_tenancy_ocid,
              "tf_var_user_ocid": $tf_var_user_ocid,
              "tf_var_fingerprint": $tf_var_fingerprint,
              "tf_var_region": $tf_var_region,
              "tf_var_private_key_pem": $tf_var_private_key_pem,
              "tf_var_compartment_ocid": $tf_var_compartment_ocid,
              "tf_var_availability_domain": $tf_var_availability_domain,
              "tf_var_os_image_id": $tf_var_os_image_id,
              "tf_var_bastion_os_image_id": $tf_var_bastion_os_image_id,
              "admin_cidrs": ($admin_cidrs | fromjson),
              "cloudflare_cidrs": ($cloudflare_cidrs | fromjson),
              "ssh_public_key": $ssh_public_key,
              "tf_state_bucket": $tf_state_bucket,
              "tf_state_key": $tf_state_key,
              "os_namespace": $os_namespace
            }' > diagnostics-output.json
          
          # We can't see the output, but we know it's created.
          echo "✅ Diagnostic file created locally."

      - name: 2. Test OCI API Credentials
        shell: bash
        run: |
          echo "### Testing OCI API Authentication ###"
          set -euo pipefail
          mkdir -p "$HOME/.oci"
          umask 077
          echo -e "${TF_VAR_private_key_pem}" > "$HOME/.oci/oci_api_key.pem"
          
          echo "Checking private key format with OpenSSL..."
          openssl rsa -in "$HOME/.oci/oci_api_key.pem" -check -noout
          echo "✅ OpenSSL key check passed."

          cat > "$HOME/.oci/config" <<CFG
          [DEFAULT]
          user=${TF_VAR_user_ocid}
          fingerprint=${TF_VAR_fingerprint}
          tenancy=${TF_VAR_tenancy_ocid}
          region=${TF_VAR_region}
          key_file=$HOME/.oci/oci_api_key.pem
          CFG
          
          echo "Attempting to authenticate with OCI CLI..."
          oci os ns get
          echo "✅ OCI CLI authentication successful."
          echo "------------------------------------"
      
      - name: 3. Discover Availability Domains
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.1
          terraform_wrapper: false
      - name: Run Availability Domain Discovery Script
        shell: bash
        run: |
          echo "### Discovering Availability Domains in ${{ env.TF_VAR_region }} ###"
          mkdir -p terraform_ad_check
          cd terraform_ad_check
          
          cat > main.tf <<EOT
          terraform {
            required_providers {
              oci = {
                source = "oracle/oci"
                version = "~> 7.17.0"
              }
            }
          }
          
          provider "oci" {
            region = "${{ env.TF_VAR_region }}"
            tenancy_ocid = "${{ env.TF_VAR_tenancy_ocid }}"
            user_ocid = "${{ env.TF_VAR_user_ocid }}"
            fingerprint = "${{ env.TF_VAR_fingerprint }}"
            private_key = "${{ env.TF_VAR_private_key_pem }}"
          }
          
          data "oci_identity_availability_domains" "ads" {
            compartment_id = "${{ env.TF_VAR_tenancy_ocid }}"
          }

          output "availability_domains" {
            value = data.oci_identity_availability_domains.ads.availability_domains
          }
          EOT
          
          terraform init
          terraform apply -auto-approve
          echo "✅ Availability Domain discovery complete."
          echo "------------------------------------"

      - name: 4. Upload Diagnostic File to OCI
        shell: bash
        run: |
          echo "### Uploading diagnostic file to OCI bucket ###"
          # The file contains sensitive data, hence the careful upload process.
          # Replace TF_STATE_BUCKET and OS_NAMESPACE if needed.
          oci os object put \
            --bucket-name "${TF_STATE_BUCKET}" \
            --namespace "${OS_NAMESPACE}" \
            --name "diagnostics-output-${{ github.run_id }}.json" \
            --file "diagnostics-output.json"
          echo "✅ Diagnostic file successfully uploaded to OCI."
      
      - name: 4.1 Decode & upload Sealed-Secrets PEMs to OCI (verification)
        shell: bash
        env:
          TF_STATE_BUCKET: ${{ env.TF_STATE_BUCKET }}
          OS_NAMESPACE: ${{ env.OS_NAMESPACE }}
          # keep secrets from environment - they are already declared at job level
          T_SEALED_SECRETS_CERT: ${{ env.T_SEALED_SECRETS_CERT }}
          T_SEALED_SECRETS_KEY:  ${{ env.T_SEALED_SECRETS_KEY }}
        run: |
          set -euo pipefail
          echo "### Decoding sealed-secrets PEMs into secure temp files (no printing). ###"

          # Basic checks
          if [ -z "${T_SEALED_SECRETS_CERT:-}" ] || [ -z "${T_SEALED_SECRETS_KEY:-}" ]; then
            echo "Skipping: T_SEALED_SECRETS_CERT or T_SEALED_SECRETS_KEY not set." >&2
            exit 0
          fi
          if ! command -v oci >/dev/null 2>&1; then
            echo "ERROR: oci CLI not installed or not in PATH." >&2
            exit 2
          fi

          TMPDIR="$(mktemp -d /tmp/sealed-verify.XXXXXX)"
          chmod 700 "$TMPDIR"
          trap 'rc=$?; if command -v shred >/dev/null 2>&1; then for f in "$TMPDIR"/* 2>/dev/null; do [ -e "$f" ] && shred -u "$f" 2>/dev/null || true; done; else rm -f "$TMPDIR"/* 2>/dev/null || true; fi; rm -rf "$TMPDIR"; exit $rc' EXIT

          KEY_PATH="$TMPDIR/sealed-secrets.key.pem"
          CRT_PATH="$TMPDIR/sealed-secrets.crt.pem"

          # Decode (use base64 --decode if available, else Python)
          if command -v base64 >/dev/null 2>&1 && base64 --help 2>&1 | grep -qE '(-d|--decode)'; then
            printf '%s' "$T_SEALED_SECRETS_KEY"  | base64 --decode > "$KEY_PATH"
            printf '%s' "$T_SEALED_SECRETS_CERT" | base64 --decode > "$CRT_PATH"
          else
            python3 - "$KEY_PATH" "$CRT_PATH" <<'PY'
            import os,base64,sys
            key_b64 = os.environ.get('T_SEALED_SECRETS_KEY')
            crt_b64 = os.environ.get('T_SEALED_SECRETS_CERT')
            if not key_b64 or not crt_b64:
                sys.exit(1)
            open(sys.argv[1],'wb').write(base64.b64decode(key_b64))
            open(sys.argv[2],'wb').write(base64.b64decode(crt_b64))
            PY
          fi

          # Restrict permissions
          chmod 600 "$KEY_PATH" "$CRT_PATH"

          # (Optional) quick validation: ensure cert is parseable
          if command -v openssl >/dev/null 2>&1; then
            if ! openssl x509 -in "$CRT_PATH" -noout >/dev/null 2>&1; then
              echo "ERROR: Decoded certificate failed OpenSSL parse check." >&2
              exit 4
            fi
            echo "Certificate parse check OK."
          fi

          # Upload both objects to the OCI bucket (names include run id for traceability)
          RUN_ID="${{ github.run_id }}"
          OBJ_KEY_NAME="sealed-secrets-${RUN_ID}.key.pem"
          OBJ_CRT_NAME="sealed-secrets-${RUN_ID}.crt.pem"

          echo "Uploading sealed-secrets key -> oci://${TF_STATE_BUCKET}/${OBJ_KEY_NAME} (namespace ${OS_NAMESPACE})"
          oci os object put --bucket-name "${TF_STATE_BUCKET}" --namespace "${OS_NAMESPACE}" --name "${OBJ_KEY_NAME}" --file "$KEY_PATH" --force >/dev/null

          echo "Uploading sealed-secrets cert -> oci://${TF_STATE_BUCKET}/${OBJ_CRT_NAME} (namespace ${OS_NAMESPACE})"
          oci os object put --bucket-name "${TF_STATE_BUCKET}" --namespace "${OS_NAMESPACE}" --name "${OBJ_CRT_NAME}" --file "$CRT_PATH" --force >/dev/null

          # verify objects exist (show object names and etags only)
          echo "Verifying uploaded objects..."
          oci os object get --bucket-name "${TF_STATE_BUCKET}" --namespace "${OS_NAMESPACE}" --name "${OBJ_KEY_NAME}" --query '{name:name,etag:etag}' --raw-output || true
          oci os object get --bucket-name "${TF_STATE_BUCKET}" --namespace "${OS_NAMESPACE}" --name "${OBJ_CRT_NAME}" --query '{name:name,etag:etag}' --raw-output || true

          echo "✅ Sealed-secrets PEMs decoded and uploaded (temporary files removed)."

      - name: 5. Check Terraform Configuration
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.1
          terraform_wrapper: false

      - name: 6. Run Terraform Init and Validate
        shell: bash
        run: |
          echo "### Initializing and Validating Terraform ###"
          terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="namespace=${OS_NAMESPACE}" \
            -backend-config="region=${TF_VAR_region}"
          
          echo "---"
          terraform validate
          echo "✅ Terraform configuration is valid."
          echo "------------------------------------"