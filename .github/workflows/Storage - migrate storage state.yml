name: 'STORAGE - Migrate Block Volume to Separate State'

on:
  workflow_dispatch:
    inputs:
      main_state_key:
        description: 'The key for the main stack state file (e.g., prod.tfstate)'
        required: true
        default: 'newsapp.tfstate'
      storage_state_key:
        description: 'The key for the NEW storage state file (e.g., storage.state)'
        required: true
        default: 'storage.tfstate'

jobs:
  migrate-state:
    name: 'Terraform State Migration'
    runs-on: ubuntu-latest

    env:
      TF_IN_AUTOMATION: "1"
      TF_INPUT: "0"

      # existing TF_VARs you already have (keep them)
      TF_VAR_tenancy_ocid:       ${{ secrets.OCI_TENANCY_OCID }}
      TF_VAR_user_ocid:          ${{ secrets.OCI_USER_OCID }}
      TF_VAR_fingerprint:        ${{ secrets.OCI_FINGERPRINT }}
      TF_VAR_region:             ${{ secrets.OCI_REGION }}
      TF_VAR_private_key_pem:    ${{ secrets.OCI_PRIVATE_KEY_PEM }}

      # ---- Add these so infra/storage sees variables named with the oci_ prefix ----
      TF_VAR_oci_tenancy_ocid:    ${{ secrets.OCI_TENANCY_OCID }}
      TF_VAR_oci_user_ocid:       ${{ secrets.OCI_USER_OCID }}
      TF_VAR_oci_fingerprint:     ${{ secrets.OCI_FINGERPRINT }}
      TF_VAR_oci_region:          ${{ secrets.OCI_REGION }}
      TF_VAR_oci_private_key_pem: ${{ secrets.OCI_PRIVATE_KEY_PEM }}

      # other storage/root vars required by infra/storage
      TF_VAR_compartment_ocid:    ${{ secrets.COMPARTMENT_OCID }}
      TF_VAR_availability_domain: ${{ secrets.AVAILABILITY_DOMAIN }}
      TF_VAR_os_namespace:        ${{ secrets.OS_NAMESPACE }}
      TF_VAR_tf_state_bucket:     ${{ secrets.TF_STATE_BUCKET }}
      TF_VAR_db_storage_ocid:     ${{ secrets.DB_STORAGE_OCID }}
        # IMPORTANT: set tf_state_key (storage workspace expects this variable)
      TF_VAR_tf_state_key:        ${{ github.event.inputs.storage_state_key }}
      # storage module expects db_instance_ocid variable; set it from a secret if you have one
      # if you don't have a secret, leaving it empty still counts as "set" for Terraform
      TF_VAR_db_instance_ocid:    ${{ secrets.DB_INSTANCE_OCID }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.1 # Using a modern version for state commands

      - name: Configure OCI Credentials
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.oci"
          umask 077
          # write the private key (echo -e handles embedded \n sequences)
          echo -e "${{ secrets.OCI_PRIVATE_KEY_PEM }}" > "$HOME/.oci/oci_api_key.pem"
          chmod 600 "$HOME/.oci/oci_api_key.pem"

          # write config pointing at the key file
          cat > "$HOME/.oci/config" <<CFG
          [DEFAULT]
          user=${{ secrets.OCI_USER_OCID }}
          fingerprint=${{ secrets.OCI_FINGERPRINT }}
          tenancy=${{ secrets.OCI_TENANCY_OCID }}
          region=${{ secrets.OCI_REGION }}
          key_file=$HOME/.oci/oci_api_key.pem
          CFG

      # --- Part 1: Remove the volume from the MAIN state file ---
      - name: Init Terraform for MAIN stack
        working-directory: ./  # Assuming main.tf is in the root
        run: |
          terraform init -reconfigure \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.main_state_key }}" \
            -backend-config="namespace=${{ secrets.OS_NAMESPACE }}" \
            -backend-config="region=${{ secrets.OCI_REGION }}"

      - name: Find Volume Resource Address in Main State
        id: find_address
        working-directory: ./
        run: |
          set -euo pipefail

          # Find first oci_core_volume resource address in main state
          ADDRESS=$(terraform state list 2>/dev/null | grep 'oci_core_volume' | head -n 1 || true)

          if [ -z "$ADDRESS" ]; then
            echo "::warning::Could not find an oci_core_volume resource in the main state file. It might have been removed already."
            echo "ADDRESS_FOUND=false" >> $GITHUB_ENV
            # leave RESOURCE_ADDRESS / RESOURCE_ID unset
          else
            echo "Found volume at address: $ADDRESS"
            # extract the resource ID (OCID) from the state BEFORE we remove it
            RESOURCE_ID=$(terraform state show -no-color "$ADDRESS" 2>/dev/null | awk -F' = ' '/^id =/ {print $2; exit}' || true)
            echo "RESOURCE_ADDRESS=$ADDRESS" >> $GITHUB_ENV
            echo "RESOURCE_ID=$RESOURCE_ID" >> $GITHUB_ENV
            echo "ADDRESS_FOUND=true" >> $GITHUB_ENV
            echo "RESOURCE_ID (captured) = $RESOURCE_ID"
          fi

      - name: Remove Volume from MAIN State
        if: env.ADDRESS_FOUND == 'true'
        working-directory: ./
        run: |
          set -euo pipefail
          echo "Removing ${{ env.RESOURCE_ADDRESS }} from ${{ github.event.inputs.main_state_key }}..."
          terraform state rm "${{ env.RESOURCE_ADDRESS }}"
          echo "✅ Removal complete."

      # --- Part 2: Init the storage workspace (and import if we have an OCID) ---
      - name: Init Terraform for STORAGE stack + import if OCID available
        working-directory: infra/storage
        # provide all TF_VARs the storage module expects so terraform won't error on "required variable"
        env:
          TF_VAR_oci_tenancy_ocid:    ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid:       ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint:     ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_region:          ${{ secrets.OCI_REGION }}
          TF_VAR_oci_private_key_pem: ${{ secrets.OCI_PRIVATE_KEY_PEM }}
          TF_VAR_compartment_ocid:    ${{ secrets.COMPARTMENT_OCID }}
          TF_VAR_availability_domain: ${{ secrets.AVAILABILITY_DOMAIN }}
          TF_VAR_os_namespace:        ${{ secrets.OS_NAMESPACE }}
          TF_VAR_tf_state_bucket:     ${{ secrets.TF_STATE_BUCKET }}
          TF_VAR_tf_state_key:        ${{ github.event.inputs.storage_state_key }}
          # storage module expects db_instance_ocid; supply from secret or empty string
          TF_VAR_db_instance_ocid:    ${{ secrets.DB_INSTANCE_OCID || '' }}
          # fallback DB OCID from repo secret (only used if main state had no ID)
          FALLBACK_DB_OCID:           ${{ secrets.DB_STORAGE_OCID || '' }}
        run: |
          set -euo pipefail
          echo "Initializing storage workspace backend..."
          terraform init -reconfigure \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.storage_state_key }}" \
            -backend-config="namespace=${{ secrets.OS_NAMESPACE }}" \
            -backend-config="region=${{ secrets.OCI_REGION }}"

          # Prefer the OCID captured from the main state earlier (if any), else fall back to the repo secret
          DB_VOLUME_OCID="${RESOURCE_ID:-}"
          if [ -z "$DB_VOLUME_OCID" ]; then
            # fallback to secret set in workflow env (FALLBACK_DB_OCID)
            DB_VOLUME_OCID="${FALLBACK_DB_OCID:-}"
          fi

          # Export so subsequent steps inside this run can access it (and print masked)
          export DB_VOLUME_OCID
          echo "DB_VOLUME_OCID='[redacted]'" # avoid printing secret OCID; we indicate presence only
          if [ -z "$DB_VOLUME_OCID" ]; then
            echo "::warning::No DB OCID available (neither found in main state nor provided via secret). Import will be skipped."
          fi

          # If the storage state already contains the resource, skip import.
          if terraform state list 2>/dev/null | grep -q '^module.storage.oci_core_volume.db_volume$'; then
            echo "module.storage.oci_core_volume.db_volume already present in storage state — skipping import."
          else
            if [ -n "$DB_VOLUME_OCID" ]; then
              echo "Attempting terraform import of module.storage.oci_core_volume.db_volume -> $DB_VOLUME_OCID"
              # import, but do not fail the job catastrophically if provider returns a weird error;
              # capture exit code, show helpful message, and continue (you can make this fatal if you prefer)
              if ! terraform import -lock=false 'module.storage.oci_core_volume.db_volume' "$DB_VOLUME_OCID"; then
                echo "::warning::terraform import failed. This could mean the volume does not exist in OCI, or the provider returned an error. Please inspect logs."
                # Optionally fail here with `exit 1` if you want import to be blocking
              else
                echo "✅ Import complete."
              fi
            else
              echo "::warning::No OCID available; skipping terraform import step."
            fi
          fi

      - name: Verify Storage State
        working-directory: infra/storage
        run: |
          set -euo pipefail
          echo "Verifying the new storage state..."
          terraform state list || true
          terraform plan || true
          echo "✅ Verification finished (plan may show changes if resource attributes differ)."